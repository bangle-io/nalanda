import { CodeBlockVanilla } from '../../../components/CodeBlock';
import { Callout, Tabs, Tab } from 'nextra-theme-docs';

# Effects

Effects help you perform side effects in your application. They come in handy for tasks like data fetching, logging, updating state or direct browser interactions.

```typescript
import { createKey } from '@nalanda/core';
import { userSlice } from './user-slice';
import { loginSlice } from './login-slice';

const key = createKey('greeting-slice', [userSlice, loginSlice]);

key.effect((store) => {
  // effect will rerun whenever userName or isLogged changes
  const { userName } = userSlice.track(store);
  const { isLoggedIn } = loginSlice.track(store);

  if (isLoggedIn) {
    console.log(`The user ${userName} is logged in`);
  } else {
    console.log(`Please login ${userName}`);
  }
});
```

<Callout>
Note: Effects are executed at least **once** after the store initializes.
</Callout>

[See Effects API doc](/docs/api/effect/)

## Tracking

Effects track any changes of select slice fields. Should a change occur, the effect is re-executed. 

You have two syntax options for tracking:

### Destructured form

This allows you to declare the values you are interested in and effect will only rerun if any of those values change.

```typescript
key.effect(store => {
  const { userName, userAddress } = userSlice.track(store);
  console.log(userName, userAddress);
})
```

### Individual access

If you donot like destructuring, you can track a single field directly:

```ts
key.effect(store => {
  const userName = userSlice.track.userName(store);
  const userAddress = userSlice.track.userAddress(store);

  console.log(userName, userAddress);
})
```

## Async Effects

Effects can also be async. When an effect is re-invoked before its prior run completes, the [cleanup](/docs/api/cleanup/) function can help manage any necessary cleanups, ensuring consistency.


```typescript
import { cleanup } from '@nalanda/core';

key.effect(async (store) => {
  const { userName } = userSlice.track(store);
  const controller = new AbortController();

  // called when effect is re-invoked
  // in this case when userName changes
  cleanup(store, () => {
    controller.abort();
  });

  const data = await fetchUserData(userName, {
    signal: controller.signal,
  });

  store.dispatch(userSlice.updateData(data));
});
```

> If you are unfamiliar with AbortController, you can read more about them [here](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).